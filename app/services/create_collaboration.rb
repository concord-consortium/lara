class CreateCollaboration

  def initialize(collaboration_endpoint_url, user, material)
    @collaboration_endpoint_url = collaboration_endpoint_url
    @user = user
    @activity = material.is_a?(LightweightActivity) ? material : nil
    @sequence = material.is_a?(Sequence) ? material : nil
  end

  def call
    ActiveRecord::Base.transaction do
      @collaboration_run = CollaborationRun.create!(
        user: @user,
        collaboration_endpoint_url: @collaboration_endpoint_url
      )
      collaborators = get_collaborators_data
      process_collaborators_data(collaborators)
    end
    @collaboration_run
  end

  private

  def bearer_token
    'Bearer %s' % @user.authentication_token
  end

  def get_collaborators_data
    response = HTTParty.get(
      @collaboration_endpoint_url, {
        :headers => {
          "Authorization" => bearer_token,
          "Content-Type" => 'application/json'
        }
      }
    )
    fail 'Collaboration data cannot be obtained' if response.response.code != "200"
    JSON.parse(response.body)
  end

  def process_collaborators_data(collaborators)
    collaborators.each do |c|
      unless User.exists?(email: c['email'])
        user = User.create!(
          email:    c['email'],
          password: User.get_random_password
        )
      else
        user = User.find_by_email(c['email'])
      end
      create_auth_token(user, c['access_token'])
      # Well, RemotePortal is a single endpoint in fact. Naming isn't consistent at all.
      portal_endpoint = RemotePortal.new(
        returnUrl: c['endpoint_url'],
        externalId: c['learner_id']
      )
      add_activity_run(user, portal_endpoint) if @activity
      add_sequence_runs(user, portal_endpoint) if @sequence
    end
  end

  def create_auth_token(user, access_token)
    # Well, this is awkward. IMHO runs should have their own
    # tokens independent from users, but for now let's just follow
    # existing pattern... One strong assumption which is present everywhere
    # is that a given user is bound only to one portal. Due to random
    # emails generated by portals it's' be true, but still it's
    # confusing and perhaps incorrect.
    user.authentications.create!(
      # Provide value isn't important, but it may be easier to identify
      # tokens created within collaboration run.
      provider: 'collaboration_run',
      token:    access_token
    )
  end

  def add_activity_run(user, portal_endpoint)
    # for_user_and_portal is in fact lookup_or_create
    run = Run.for_user_and_portal(user, @activity, portal_endpoint)
    @collaboration_run.runs.push(run)
  end

  def add_sequence_runs(user, portal_endpoint)
    sequence_run = SequenceRun.lookup_or_create(@sequence, user, portal_endpoint)
    @collaboration_run.runs.push(*sequence_run.runs)
  end

end
